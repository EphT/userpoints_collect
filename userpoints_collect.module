<?php

/**
 * @file
 * Provides a block for users to collect points within time constraints.
 */

define('USERPOINTS_COLLECT_MODE_ARRAY', 1);
define('USERPOINTS_COLLECT_MODE_INTERVAL', 2);

/**
 * Implements hook_permission().
 */
function userpoints_collect_permission() {
  return array(
    'use userpoints collect' => array(
      'title' => t('use userpoints collect'),
      'description' => t('Allows users to use the userpoints collect block.'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function userpoints_collect_theme() {
  return array(
    'userpoints_collect_form' => array(
      'render element' => 'form',
      'template' => 'userpoints-collect-form'
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function userpoints_collect_block_info() {
  return array(
    'userpoints_collect' => array(
      'info' => t('Userpoints Collect'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

/**
 * Implements hook_block_configure().
 */
function userpoints_collect_block_configure($delta = '') {
  // This example comes from node.module.
  $form = array();

  // retrieve config array from db
  $config = variable_get('userpoints_collect_form_config', NULL);

  if ($config == NULL) {
    $config = userpoints_collect_form_defaults();
  }

  if ($delta == 'userpoints_collect') {
    $form['submit_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Submit Button label'),
      '#required' => TRUE,
      '#default_value' => $config['submit_label'],
    );
    $form['return_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Return to Site label'),
      '#required' => TRUE,
      '#default_value' => $config['return_label'],
    );
    $form['return_url'] = array(
      '#type' => 'textfield',
      '#title' => t('Return to Site URL'),
      '#required' => TRUE,
      '#default_value' => $config['return_url'],
    );
    $form['no_ballots_label'] = array(
      '#type' => 'textfield',
      '#title' => t('No ballots remaining label'),
      '#required' => TRUE,
      '#default_value' => $config['no_ballots_label'],
    );
    $form['next_ballot_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Next ballot available in... label'),
      '#description' => 'Label must contain @timeleft to indicate where time left until next ballot should be displayed',
      '#required' => TRUE,
      '#default_value' => $config['next_ballot_label'],
    );
    $form['after_collect_path'] = array(
      '#type' => 'textfield',
      '#title' => t('After collect path'),
      '#description' => 'Redirect to this path after user collects a point',
      '#required' => TRUE,
      '#default_value' => $config['after_collect_path'],
    );

  }
  return $form;
}

/**
 * Returns an array of defaults for userpoints_collect config form
 */
function userpoints_collect_form_defaults() {
  return array(
    'submit_label' => t('Collect now!'),
    'return_label' => t('Back to Facebook'),
    'return_url' => 'http://facebook.com',
    'no_ballots_label' => t('No more ballots remaining'),
    'next_ballot_label' => t('Next ballot available in @timeleft'),
    'after_collect_path' => '<front>',
  );
}

/**
 * Implements hook_block_save().
 */
function userpoints_collect_block_save($delta = '', $edit = array()) {
  // This example comes from node.module.
  if ($delta == 'userpoints_collect') {
    $config = array(
      'submit_label' => $edit['submit_label'],
      'return_label' => $edit['return_label'],
      'return_url' => $edit['return_url'],
      'no_ballots_label' => $edit['no_ballots_label'],
      'next_ballot_label' => $edit['next_ballot_label'],
      'after_collect_path' => $edit['after_collect_path'],
    );

    variable_set('userpoints_collect_form_config', $config);
  }
}

/**
 * Implements hook_block_view().
 */
function userpoints_collect_block_view($delta = '') {
  if ( $delta == 'userpoints_collect' && user_access('use userpoints collect') ) {
    return array(
      'content' => drupal_get_form('userpoints_collect_form'),
    );
  }
}

/**
 * Returns a Userpoints collect form.
 */
function userpoints_collect_form($form, &$form_state) {
  global $user;
  $access = userpoints_collect_access();

  $config = variable_get('userpoints_collect_form_config', NULL);

  if ( $access ) {
    $form['submit'] = array(
      //'#disabled' => !$access,
      '#type' => 'submit',
      '#value' => t($config['submit_label']),
    );
  }
  else {
    $form['#disabled'] = TRUE;
    $form['link'] = array(
      '#prefix' => '<p>',
      '#suffix' => '</p>',
      '#markup' => l(t($config['return_label']), $config['return_url'], array('attributes' => array('class' => array('btn', 'btn-large', 'btn-primary')))),
    );

    $timeleft = userpoints_collect_eligibility_timeleft();
    $ballot_message = !$timeleft ? t($config['no_ballots_label']) : t($config['next_ballot_label'], array('@timeleft' => $timeleft));

    $form['timeleft'] = array(
      '#markup' => $ballot_message,
    );
  }

  return $form;
}

/**
 * Validate a Userpoints collect form submission.
 */
function userpoints_collect_form_validate($form, &$form_state) {
  //drupal_set_message(__FUNCTION__);
}

/**
 * Process a Userpoints collect form submission.
 */
function userpoints_collect_form_submit($form, &$form_state) {
  global $user;

  userpoints_collect_add(array(
    'uid' => $user->uid,
    'points' => 1,
  ));

  $config = variable_get('userpoints_collect_form_config', userpoints_collect_form_defaults());

  $form_state['redirect'] = $config['after_collect_path'];
}

/**
 * Determine whether the user has access to collect userpoints.
 *
 * @param $account
 *   (optional) The account to check, if not given use currently logged in user.
 * @return
 *   Boolean TRUE if the account has the requested permission.
 */
function userpoints_collect_access($account = NULL) {
  global $user;

  if ( !isset($account) ) {
    $account = $user;
  }

  // User #1 has privileges.
  if ( $account->uid == 1 ) {
    return TRUE;
  }

  // Check if account has permission and is eligible to collect.
  if ( user_access('use userpoints collect', $account) && userpoints_collect_eligibility($account) ) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Returns whether a user is eligible to collect a point.
 *
 * @param $account
 *   A user object.
 * @return
 *   Boolean TRUE if the account is eligible.
 */
function userpoints_collect_eligibility($account = NULL) {
  $last_txns = drupal_static(__FUNCTION__, array());

  if ( !isset($account) ) {
    global $user;
    $account = $user;
  }

  // Load the last transaction by user.
  if ( !isset($last_txns[$account->uid]) ) {
    $last_txns[$account->uid] = db_select('userpoints_txn', 'u')
      ->fields('u')
      ->condition('uid', $account->uid)
      ->orderBy('time_stamp', 'DESC')
      ->range(0, 1)
      ->execute()
      ->fetchObject();
  }


  $last_txn = $last_txns[$account->uid];
  if ($last_txn) {
    $last_timestamp = $last_txn->time_stamp;
  }

  // get the eligibility period (min and max timestamp)
  // that the current time would fall into
  $period = userpoints_collect_dates_get_eligibility_period();
  // if period returns false, it means there are no periods of eligibility
  // (at least not yet)
  if (!$period) {
    return FALSE;
  }
  else {
    $eligibility_period_min = $period['min'];
    $eligibility_period_max = $period['max'];
  }

  // check if valid timestamps were retrieved for min / max
  // eligibility periods
  if ( isset($eligibility_period_min) && $eligibility_period_min > 0
    && isset($eligibility_period_max) && $eligibility_period_max > 0 ) {

    if (!isset($last_timestamp)) {
      // user has no point transactions on record
      // check current time if it is within eligibility period
      return $eligibility_period_min < time() && $eligibility_period_max > time();
    }
    else {
      // the user has point transaction(s) on record
      if ( $last_timestamp > $eligibility_period_min
        && $last_timestamp < $eligibility_period_max ) {
        // user's last point claimed is within the eligibility period
        return FALSE;
      }
      else {
        // drupal_set_message( t('Next eligibility period from @min to @max', array('@min' => $eligibility_period_min,'@max' => $eligibility_period_max,)) );
        return TRUE;
      }
    }
  }
  else {
    // No eligible dates were found in the database
    return FALSE;
  }

  // Something went wrong.
  return FALSE;
}

/**
 * Returns an array of the min/max interval timestamps
 * in which a specified timestamp occurs
 *
 * @param $timestamp
 *    the unix timestamp to get eligibility period for
 *    will default to current time if not specified
 */
function userpoints_collect_dates_get_eligibility_period($timestamp = NULL) {
  if (is_null($timestamp)) {
    $timestamp = time();
  }

  if ( (int)variable_get('userpoints_collect_dates_eligibility_mode', USERPOINTS_COLLECT_MODE_INTERVAL) == USERPOINTS_COLLECT_MODE_INTERVAL) {
    // retrieve interval settings from variables table and do
    // an interval-based calculation for next eligibility period
    $interval_settings = variable_get('userpoints_collect_dates_interval', NULL);
    if (is_null($interval_settings)) {
      // default interval settings
      // create ten 3-minute intervals starting 10 seconds from now
      $interval_settings = userpoints_collect_date_load_default_interval_settings();
    }

    // return false (no eligibility period) if the
    // current time is before first/earliest eligibility period
    // or the current time is past the final/latest eligibility period
    if ($timestamp < $interval_settings['first'] || $timestamp > $interval_settings['final']) {
      return FALSE;
    }

    $period = array(
      'first' => $interval_settings['first'],
      'final' => $interval_settings['final'],
    );

    $count = $interval_settings['first'];

    // calculate the range this timestamp falls in
    while ($count < $timestamp) {
      $count += $interval_settings['interval'];
      // when counter passes the timestamp,
      // we know we've reached the max for the period of eligibility
      if ($count >= $timestamp) {
        $period['max'] = $count;
        $period['min'] = $count - $interval_settings['interval'];
      }
    }

    // TODO: remove after debug
    // $format = "%H:%M:%S";
    // dsm(t('Interval settings: @initial, @interval, @final', array(
    //   '@first' => strftime($format, $interval_settings['first']),
    //   '@interval' => $interval_settings['interval'],
    //   '@final' => strftime($format, $interval_settings['final']),
    // )));
    // dsm(t('Eligibility period: @min to @max', array(
    //   '@min' => strftime($format, $period['min']),
    //   '@max' => strftime($format, $period['max']),
    // )));

  }
  else {
    // Array based calculation
    $times = variable_get('userpoints_collect_dates_array', NULL);
    if (is_null($times)) {
      $times = userpoints_collect_dates_generate_array();
      variable_set('userpoints_collect_dates_array', $times);
    }

    // TODO: remove after debug
    // $format = "%H:%M:%S";
    //     $all_times = "";
    //     for ($i = 0; $i < count($times); $i++) {
    //       $all_times .= strftime($format, $times[$i]) . " ";
    //     }
    // dsm(t($all_times));

    // return false (no eligibility period) if the
    // current time is before first/earliest eligibility period
    // or the current time is past the final/latest eligibility period
    if (time() < $times[0] || time() > $times[count($times) - 1]) {
      return FALSE;
    }

    $period = array();
    $period['first'] = $times[0];
    $period['final'] = $times[count($times) - 1];

    // sort the times in descending order before
    // iterating over them
    rsort($times, SORT_NUMERIC);

    // find the minimum/maximum time for the eligibility period
    for ($i = 0; $i < count($times); $i++) {
      // handle boundary cases
      if ($times[$i] == $timestamp) {
        // timestamp = final(latest) timestamp in array
        if ($i == 0) {
          $period['min'] = $period['final'];
          $period['max'] = $times[1];
        }
        // timestamp = first(earliest) timestamp in array
        elseif ($i == count($times) - 1) {
          $period['min'] = count($times) - 2;
          $period['max'] = $period['first'];
        }
      }
      else {
        if ($times[$i] < $timestamp) {
          $period['min'] = $times[$i];
          $period['max'] = $times[$i - 1];

          // TODO: Remove after debug
          // $format = "%H:%M:%S";
          // dsm(t('Eligibility period: @min to @max', array(
          //   '@min' => strftime($format, $period['min']),
          //   '@max' => strftime($format, $period['max']),
          //   )));

          break;
        }
      }
    }
  }

  return $period;
}

/**
 * Returns next timestamp for when the user can collect
 * a point, or false if there are no upcoming eligible times.
 */
function userpoints_collect_next_eligible_time() {
  $period = userpoints_collect_dates_get_eligibility_period();
  // return the period max (upcoming time) only if that max
  // isn't the last eligible time
  return $period['max'] < $period['final'] ? $period['max'] : FALSE;
}

/**
 * Returns the time left for collect eligibility.
 */
function userpoints_collect_eligibility_timeleft() {
  $next_eligible = userpoints_collect_next_eligible_time();

  if ($next_eligible && $next_eligible > 0) {
    return format_interval($next_eligible - time());
  }
  else {
    return FALSE;
  }
}

/**
 * Add points for a user.
 */
function userpoints_collect_add($params) {
  if ( userpoints_collect_access(user_load($params['uid'])) ) {
    return userpoints_userpointsapi($params);
  }

  return array(
    'status' => FALSE,
    'reason' => t('User is not eligible.'),
  );
}

/**
 * Returns an array of possible collect restriction periods.
 */
function userpoints_collect_eligibility_periods() {
  return array(
    NULL => 'Never',
    60 => '1 minute',
    300 => '5 minutes',
    600 => '10 minutes',
    900 => '15 minutes',
    1800 => 'Half hour',
    3600 => 'One hour',
    86400 => 'One Day',
    604800 => 'One Week',
    1209600 => 'Two Weeks',
    2419200 => 'Four Weeks',
    31536000 => '365 Days',
  );
}

/**
 * Process variables for userpoints-collect-form.tpl.php
 *
 * The $variables array contains the following arguments:
 * - $form
 *
 * @see userpoints-collect-block-form.tpl.php
 */
function template_preprocess_userpoints_collect_form(&$variables) {
  $variables['userpoints_collect'] = array();
  foreach ( element_children($variables['form']) as $key ) {
    $variables['userpoints_collect'][$key] = drupal_render($variables['form'][$key]);
  }

  $variables['userpoints_collect_form'] = implode($variables['userpoints_collect']);
}

/**
 * Removes any userpoints_collect date interval settings from the database
 */
function userpoints_collect_date_clear_interval_settings() {
  variable_del('userpoints_collect_dates_interval');
}

/**
 * Sets default values for intervals into Drupal's variables database table.
 *
 * @param $interval_length
 *    the time in seconds that each period of eligibility should last
 *    default: 180 (3 minutes)
 * @param $repeat
 *    the number of intervals
 *    default: 10
 */
function userpoints_collect_date_set_interval_settings($interval_length = 180, $repeat = 10) {
  userpoints_collect_date_clear_interval_settings();
  $interval_settings = array();
  $interval_settings['first'] = time() + 10;
  $interval_settings['interval'] = $interval_length;
  $interval_settings['final'] = time() + $interval_length * $repeat;
  variable_set('userpoints_collect_dates_interval', $interval_settings);
  drupal_set_message(
     t('Successfully generated @repeat intervals, @secs_apart @sec_pluralized apart.', array(
       '@repeat' => $repeat,
       '@secs_apart' => $interval_length,
       '@sec_pluralized' => format_plural($secs_apart, 'second', 'seconds')
       )
     )
   );
}

/**
 * Returns an array containing the default interval settings
 *
 * Specifically, returns an array of ten timestamps, spaced in one-minute
 *  intervals starting ten seconds from now
 */
function userpoints_collect_date_load_default_interval_settings() {
  $interval_settings = array();
  $interval_settings['first'] = time() + 10;
  $interval_settings['interval'] = 60;
  $interval_settings['final'] = time() + $interval_settings['interval'] * 10;
  return $interval_settings;
}

/**
 * Convenience function to clear all point transactions
 */
function userpoints_collect_clear_all_points() {
  db_truncate('userpoints_txn')->execute();
  drupal_set_message(t('Cleared all point transactions'));
}

/**
 * Clears out userpoints_collect timestamp timestamps set in variables table
 */
function userpoints_collect_dates_clear_array() {
  variable_del('userpoints_collect_dates_array');
}

/**
 * Generates an array of ordered or shuffled timestamps
 *
 * @param $random_dist
 *    randomizes the distribution (time between dates)
 * @param $shuffle
 *    shuffles the elements of the array
 * @param $number_of_timestamps
 *    the number of timestamps to generate
 * @param $minutes_apart
 *    the number of minutes between each timestamp in the array
 */
function userpoints_collect_dates_generate_array($random_dist = FALSE, $shuffle = FALSE, $number_of_timestamps = 5, $minutes_apart = 1) {
  $dates = array();
  // array_push($dates, time() + 10);
  for ( $i = 1; $i <= $number_of_timestamps; $i++ ) {
    // if random_dist is true, a multiplier (from 1-5) will be factored into each date
    $random_dist == TRUE ? $multiplier = rand(1, 5) : $multiplier = 1;
    array_push( $dates, time() + ($i * $minutes_apart * $multiplier * 60) );
  }

  if ($shuffle == TRUE) {
    shuffle($dates);
  }

  drupal_set_message(
    t('Successfully generated an array of @number_of_timestamps @random_dist dates, @minutes_apart @min_pluralized apart@shuffled', array(
      '@random_dist' => $random_dist == TRUE ? 'randomly distributed' : 'evenly distributed',
      '@number_of_timestamps' => $number_of_timestamps,
      '@minutes_apart' => $random_dist == TRUE ? 'x' : $minutes_apart,
      '@min_pluralized' => $random_dist == TRUE ? "minutes" : format_plural($minutes_apart, 'minute', 'minutes'),
      '@shuffled' => $shuffle == TRUE ? ', and then shuffled them.' : '.',
      )
    )
  );
  return $dates;
}

/**
 * Saves an array of timestamps to Drupal's variables table
 */
function userpoints_collect_dates_generate_and_save_array($randomized = FALSE, $shuffle = FALSE, $number_of_timestamps = 5, $minutes_apart = 1) {
  userpoints_collect_dates_clear_array();
  $dates = userpoints_collect_dates_generate_array($randomized, $shuffle, $number_of_timestamps, $minutes_apart);
  variable_set('userpoints_collect_dates_array', $dates);
}